//摆上一排花，共 m 盆。
//通过调查顾客的喜好，小明列出了顾客最喜欢的 n 种花，从 1 到 n 标号。
//为了在门口展出更多种花，规定第 i 种花不能超过 a i盆，
//摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。
//试编程计算，一共有多少种不同的摆花方案。

//输入格式
//第一行包含两个正整数 
//n 和 m，中间用一个空格隔开。
//第二行有 n 个整数，每两个整数之间用一个空格隔开，依次表示 a 1,a 2 ...a n

// 输出格式
//一个整数，表示有多少种方案。
//注意：因为方案数可能很多，请输出方案数对 10^6+7 取模的结果。
//乍一看，还会以为这道题很难，其实就是要知道每种花最多可以放几盆，然后就穷举有多少种方法
//首先还是来输入吧
#include<stdio.h>
#include<string.h>
int main()
{
	//n表示花的品种数，m表示一共放几盆花 
	int n,m;
	scanf("%d%d",&n,&m);
	//因为是ai,所以我们就直接声明数组来保存
	//因为花盆标号从1开始，所以i从1开始 
	int arr[101]={0}; 
	int i=0;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&arr[i]);
	} 
	//请忽略我接下来的注释，因为在写这段注释之前我不知道
	//动态规划的背包问题
	//接下来我将用动态规划的思维来解题
	//首先，我们明确，m代表的是背包容量
	//1~n是物品的编号
	//ai代表的是物品的价值
	//我们要得到f(n,m)的最优解
	//就是价值最大时，也就是摆花方案数量最多
	//那我们就来执行一下试试
	int b[101][101]={0};
	i=0;
	//当背包容量为0时，能装的价值为0 
	//但是这里是摆放方法，所以是1种，就是什么都不放 
	for(i=0;i<=n;i++)
	{
		b[i][0]=1;
	} 
	
	i=0;
	for(i=1;i<=n;i++)
	{
		int j=0;
		for(j=1;j<=m;j++)
		{
			int k=0;
			for(k=j;k>=j-arr[i];k--)
			{
				if(k>=0)
				{
					b[i][j]+=b[i-1][k]%1000007;
					//i是剩下可以拿的物品，j是背包剩余的容量 
					//不要忘记模1000007
					b[i][j]%=1000007; 
				}
				else 
				break;
				//此时k<0,就是说没有东西可以拿了，退出 
			}
		}
	}
	//错误注释	
	//接下来就是看操作了
	//主体部分就是用循环来不断排列组合
	//我们看题目的描述，就是在说同一种花要放在一起，
	//然后还不能超过对应的ai,也就是arr[i] 
	//那么，我们应该怎么循环呢
	//我认为，因为我们摆放每种花的数量可以不一样
	//所以这里肯定是有一个循环来确定这次摆放可以放几盆
	//然后就是第二个循环来确定摆放的顺序，
	//稍等，这里我们可不可以先确定一个顺序比如1,2,3...号花这样
	//然后就能知道，哦哦，不好意思，忽略了题目的一个条件
	//题目已经说了，不同品种的花必须按从小到大的顺序摆放，
	//那我们就不需要再给他打乱顺序再来一次了
	//还有不能搞忘的是最后总数加起来一定是m盆  
	//开始操作
	//我去，这个循环怎么搞
	//首先，我肯定需要一个式子就是每种花的花盆数相加最后等于m
	//但是，问题也出在这里，我们
	//好好好，开一个二维数组，用来保存第i种花有j盆，不是放了多少盆 
	//就是arr[i][j]
	//然后就是动态规划
	//不断递加
	//不过我们还需要一个k用来表示放几盆某种花 
	printf("%d\n",b[n][m]);
	
	return 0; 
 } 
 
 
